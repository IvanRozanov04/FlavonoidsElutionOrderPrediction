# Data analysis
import numpy as np 
from itertools import combinations
from Modules.FingerPrints.GeneratingFunctions import SecondDegreeFP_bits

def symmetric_swap(x, pairs=[(5,9),(6,8)],offset = 10):
    """
    Symmetrically swap specified pairs of bits in both halves of the first-degree fingerprint parts,
    then recompute the second-degree fingerprint bits based on the swapped first-degree parts.

    The input fingerprint vector `x` is assumed to be concatenated as:
    - First-degree part 1: bits [0 : offset]
    - First-degree part 2: bits [offset : 2*offset]
    - Second-degree part: bits [2*offset : ...]

    This function swaps each pair `(i, j)` in the first-degree parts symmetrically:
    - Swap bits `i` and `j` in the first-degree part 1
    - Swap bits `i+offset` and `j+offset` in the first-degree part 2

    After swapping, it recomputes the second-degree bits by calling `SecondDegreeFP_bits` on the modified
    first-degree bits (concatenated parts 1 and 2). The output fingerprint vector is then truncated to
    the original length of `x` to preserve the input size (e.g., avoid promoting first-degree to second-degree length).

    Parameters
    ----------
    x : np.ndarray
        Flattened fingerprint vector. Length >= 2 * offset.
        The first 2 * offset bits represent two concatenated first-degree fingerprint parts.
        Remaining bits (if any) represent second-degree interactions.
    pairs : list of tuple of int, optional
        List of index pairs `(i, j)` referring to positions within the first-degree parts to swap symmetrically.
        Default is [(5, 9), (6, 8)].
    offset : int, optional
        Length of each first-degree part (default 10).

    Returns
    -------
    np.ndarray
        Fingerprint vector with swapped first-degree bits and recomputed second-degree bits,
        truncated to the original length of `x`.

    Example
    -------
    >>> x = SecondDegreeFP(sub_dict)  # shape might be > 20 (two first-degree parts plus second-degree)
    >>> x_swapped = symmetric_swap(x, pairs=[(5,9),(6,8)], offset=10)
    """
    x_new = np.copy(x)[:offset*2]
    for i, j in pairs:
        x_new[i], x_new[j] = x_new[j], x_new[i]
        x_new[i+offset], x_new[j+offset] = x_new[j+offset], x_new[i+offset]
    output = (SecondDegreeFP_bits(x_new))[:len(x)]
    return output

def create_lp(x1,x2,y1,y2,symmetric_pos=[(5,9),(6,8)]):
    """
    Create pairwise difference feature vectors and corresponding ranking labels for a pair of samples,
    with optional symmetric augmentation via symmetric swaps on the fingerprint vectors.

    The function computes difference vectors for the input pairs (x1, x2) and their label comparisons (y1, y2),
    then augments these pairs by applying symmetric swaps (using `symmetric_swap`) on the fingerprints,
    generating additional difference vectors to enhance training data diversity.

    Parameters
    ----------
    x1, x2 : np.ndarray
        Fingerprint vectors for the two samples to be compared.
    y1, y2 : float
        Scalar labels or scores associated with x1 and x2, respectively.
    symmetric_pos : list of tuple of int, optional
        List of index pairs indicating positions in the fingerprint to be symmetrically swapped during augmentation.
        Default is [(5,9), (6,8)].

    Returns
    -------
    output_pairs : list of np.ndarray
        List of difference vectors (feature-wise differences) computed as all combinations of
        original and symmetrically swapped fingerprints: (x1 - x2), (x2 - x1), and augmented pairs.
    output_labels : list of bool
        List of boolean labels indicating ranking order for each difference vector:
        True if the first fingerprint's label is greater than the second's (y_i > y_j), False otherwise.

    Notes
    -----
    - The difference vectors include the original pair differences and those generated by swapping
      fingerprint bits symmetrically according to `symmetric_pos`.
    - This augmentation helps the model learn invariances to symmetric transformations in the fingerprints.

    Example
    -------
    >>> pairs, labels = create_lp(x1, x2, y1, y2)
    >>> for p, l in zip(pairs, labels):
    ...     print(p.shape, l)
    """
    output_pairs = [x1-x2,x2-x1]
    output_labels = [y1>y2,y2>y1]
    if len(symmetric_pos) != 0:
        offset = 10
        x1_inv = symmetric_swap(x1,symmetric_pos,offset=offset)  
        x2_inv = symmetric_swap(x2,symmetric_pos,offset=offset)
        output_pairs.append(x1_inv-x2)
        output_pairs.append(x2-x1_inv)
        output_labels.append(y1>y2)
        output_labels.append(y2>y1)
        output_pairs.append(x1-x2_inv)
        output_pairs.append(x2_inv-x1)
        output_labels.append(y1>y2)
        output_labels.append(y2>y1)
        output_pairs.append(x1_inv-x2_inv)
        output_pairs.append(x2_inv-x1_inv)
        output_labels.append(y1>y2)
        output_labels.append(y2>y1)  
    return output_pairs,output_labels
        
def linear_pairs(X, y, DOIs,sym_p = [(5,9),(6,8)]):
    """
    Generate pairwise difference vectors and ranking labels from dataset samples,
    restricting pairs to those sharing the same DOI (document/source) and having different target values.

    Each pair of samples (i0, i1) with the same DOI and different `y` values is passed to `create_lp`
    to produce difference vectors (feature-wise differences) and corresponding boolean labels for ranking.
    Symmetric augmentation using the specified bit swap positions can be applied.

    Parameters
    ----------
    X : array-like, shape (n_samples, n_features)
        Array or list of fingerprint vectors for all samples.
    y : array-like, shape (n_samples,)
        Target scalar values (e.g., retention times or scores) for each sample.
    DOIs : list or array-like, shape (n_samples,)
        Identifiers (e.g., document or source IDs) indicating grouping of samples.
        Only pairs from the same DOI are considered.
    sym_p : list of tuple of int, optional
        Positions for symmetric swaps used in `create_lp` augmentation.
        Default is [(5,9), (6,8)].

    Returns
    -------
    parameters : np.ndarray, shape (?, n_features)
        Array of difference vectors (x_i - x_j) produced for each qualifying pair and its symmetric augmentations.
    labels : np.ndarray, shape (?,)
        Boolean array indicating whether the first sample in each pair has a greater target value than the second (y_i > y_j).

    Notes
    -----
    - The function randomizes the order of pair combinations for diversity.
    - Only pairs from the same DOI with differing target values are processed.
    - The output arrays contain difference vectors and labels for all generated pairs, including symmetric augmented pairs.

    Example
    -------
    >>> params, labs = linear_pairs(X, y, DOIs)
    >>> print(params.shape, labs.shape)
    """
    combs = list(combinations(range(len(y)), 2))
    np.random.seed(42)
    np.random.shuffle(combs)

    X = np.array(X)
    y = np.array(y)
    labels = []
    parameters = []

    for i0, i1 in combs:
        if DOIs[i0] == DOIs[i1] and np.abs(y[i0] - y[i1]):
            pairs,labs = create_lp(X[i0],X[i1],y[i0],y[i1],sym_p)
            for pair in pairs:
                parameters.append(pair)
            for lab in labs:
                labels.append(lab)

    return np.array(parameters), np.array(labels)
